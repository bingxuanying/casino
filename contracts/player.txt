
  function placeBet(BetPointPrm[] calldata betPoints) public {
    RouletteLaunchLib.checkRouletteIsUnlockedForPlayer(s.rcs, betPoints);

    uint256 playerBalance = s.cs.playersBalances[msg.sender];
    require(playerBalance >= 100, "Balance is empty");
    uint256 totalBetSum = RouletteLaunchLib.getTotalBetSum(betPoints);

    uint256 lockHouseAmount = LibRulette.getRequiredHouseLockAmount(betPoints);
    console.log("Locking total:", lockHouseAmount);
    LibHLP.LockAmountFromHouse(s.hs, lockHouseAmount);
    CashierStorageLib.LockBetAmount(s.cs, totalBetSum, msg.sender);
    // //console.log("**********************************");

    RouletteLaunch storage rl = s.rcs.playersLaunchedRoulette[msg.sender];
    RouletteLaunchLib.storeBetPoints(rl, betPoints);
    rl.lockedHouseAmountEth = lockHouseAmount;

    rl.requestId = launchRoulette();
    s.rcs.userAddressByRequestId[rl.requestId] = msg.sender;
    // //console.log(
    //     "Placing the bet",
    //     rl.requestId,
    //     msg.sender,
    //     userAddressByRequestId[rl.requestId]
    // );
    emit RouletteLaunched(rl.requestId);
  }

  event RouletteLaunched(uint256 requestId);

  /**
   * @notice Requests randomness
   * Assumes the subscription is funded sufficiently; "Words" refers to unit of data in Computer Science
   */
  function launchRoulette() private returns (uint256) {
    uint32 CALLBACK_GAS_LIMIT = 1000000;

    // The default is 3, but you can set this higher.
    uint16 REQUEST_CONFIRMATIONS = 3;

    // For this example, retrieve 2 random values in one request.
    // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.
    uint32 NUM_WORDS = 1;
    // Will revert if subscription is not set and funded.
    VrfInfoStruct storage vrfInfo = s.rcs.vrfInfo;

    require(vrfInfo.vrfCoordinatorAddress != address(0x0), "vrfInfo not set");
    VRFCoordinatorV2Interface COORDINATOR = VRFCoordinatorV2Interface(
      vrfInfo.vrfCoordinatorAddress
    );
    uint256 s_requestId = COORDINATOR.requestRandomWords(
      vrfInfo.keyHash,
      vrfInfo.subscriptionId,
      REQUEST_CONFIRMATIONS,
      CALLBACK_GAS_LIMIT,
      NUM_WORDS
    );

    return s_requestId;
  }

  event RouletteStopped(
    uint256 requestId,
    uint256 randomWord,
    uint256 resultNum
  );
  event RouletteStoppedVRFCallReceived();
  event RouletteStoppedRequestIdRecognized(bool);
  event RouletteLaunchOfPlayerFound(bool);
  event RouletteStoppedPrizeInfo(
    uint256 requestId,
    uint256 randomWord,
    uint256 resultNum,
    uint256[10] winByPosition
  );

  /**
   * @notice Callback function used by VRF Coordinator
   *
   * @param requestId - id of the request
   * @param randomWords - array of random results from VRF Coordinator
   */
  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords)
    internal
  {
    console.log("fulfillRandomWords", requestId, randomWords[0]);
    emit RouletteStoppedVRFCallReceived();

    uint256 resultnum = randomWords[0] % 38;
    if (resultnum == 0) {
      resultnum = 38;
    }
    uint8 resultnum8 = uint8(resultnum);
    emit RouletteStopped(requestId, randomWords[0], resultnum);
    // //console.log(
    //     "emitting RouletteStopped",
    //     requestId,
    //     randomWords[0],
    //     resultnum
    // );
    address playerAddress = s.rcs.userAddressByRequestId[requestId];

    if (playerAddress == address(0)) {
      //request not registered
      //console.log("playerAddress is empty");
      emit RouletteStoppedRequestIdRecognized(false);
      return;
    }
    delete s.rcs.userAddressByRequestId[requestId];
    emit RouletteStoppedRequestIdRecognized(true);

    RouletteLaunch memory rl = s.rcs.playersLaunchedRoulette[playerAddress];
    if (rl.requestId != requestId) {
      emit RouletteLaunchOfPlayerFound(false);
      //console.log("rl.requestId != requestId");
      return; //Don't revert
    }
    //console.log("emitting RouletteLaunchOfPlayerFound(true)");
    emit RouletteLaunchOfPlayerFound(true);

    delete s.rcs.playersLaunchedRoulette[playerAddress];
    uint256 totalBetSum;
    uint256 totalWinSum;
    uint256 betPointQnt = rl.betPoints.length;
    uint256[10] memory winByPosition;
    for (uint256 index; index < betPointQnt; ++index) {
      BetPoint memory p = rl.betPoints[index];
      totalBetSum += p.amount;
      //check bet param

      uint256 winFact = LibRulette.getWinFactor(
        p.betType,
        p.betDet,
        resultnum8
      );

      if (winFact > 0) {
        uint256 won = (p.amount * winFact);
        totalWinSum += won;
        p.won = won;
        winByPosition[index] = won;
      }
      //console.log(
      //     "returned winfactor",
      //     index,
      //     totalBetSum,
      //     totalWinSum
      // );
    }
    //console.log("Betpoints calculated");

    //unlock balances
    LibHLP.UnlockBalances(s.hs, rl.lockedHouseAmountEth);
    CashierStorageLib.UnlockBetAmount(s.cs, totalBetSum, playerAddress);
    int256 payDiff = int256(totalBetSum);

    if (totalWinSum > 0) {
      //console.log(
      //     "Player wins",
      //     totalWinSum * 1e2,
      //     s.cs.playersBalances[playerAddress]
      // );
      s.cs.playersBalances[playerAddress] += totalWinSum * 1e2; //keeps in Cahsier
      payDiff -= int256(totalWinSum);
    }

    if (payDiff < 0) {
      //console.log("House=>Cashier", uint256(-payDiff));
      //player wins amount
      //transfer from HLP to Cashier
      LibHLP.transferFromHouse2Cashier(s, uint256(-payDiff));
    } else if (payDiff > 0) {
      //player lost all
      //transfer from to Cashier to HLP
      LibHLP.transferFromCashierToHouse(s, uint256(payDiff));
    }
    /*  //console.log("payDiff", payDiff);
        //console.log("emitting RouletteStoppedPrizeInfo");*/
    emit RouletteStoppedPrizeInfo(
      requestId,
      randomWords[0],
      resultnum,
      winByPosition
    );
  }